# Линейные списки
## Стек

**Стек** - *абстрактный* тип данных, работающий по принципу `LIFO` - Last in, first out (Последним вошёл - первый вышел).

Операции:
- `nullStack` - обнуление стека
- `empty` - проверка на пустоту
- `push` - добавление элемента в стек
- `pop` - удаление элемента из стека

### Реализация стека массивом

```cpp
struct Stack1 {
	int top;
	int *data;
};

void InitStack (Stack1 &st, int capacity)
{ st.data = new int[capacity]; st.top = -1; }

void push (Stack1 &st, int value)
{ st.data[++st.top] = value; }

int pop (Stack1 &st)
{ return st.data[st.top--]; }

void nullStack (Stack1 &st)
{ st.top = -1; }

bool empty (Stack1 &st)
{ return st.top == -1; }
```
Здесь лишь не хватает проверок на переполнение стека и взятие из пустого.

### Реализация динамическим списком

Основной недостаток реализации стека массивом в том, что из-за ограниченного размера массива может произойти переполнение стека.

Реализация динамической структуры лишена этого недостатка. Размер стека ограничен только памятью компьютера.

```cpp
struct Node {
	int data;
	Node *next;
};

void initStack (Node *top) { top = NULL; }

void push (Node *top, int value) {
	Node *tmp = new Node;
	tmp->next = top;
	top = tmp;
	top->data = value;
}

int pop(Node *top) {
	Node *tmp = top;
	int d = top->data;
	top = top->next;
	delete tmp;
	return d;
}

bool empty (Node *top) {
	Node *tmp;
	while (!empty(top)) {
		tmp = top;
		top = top->next;
		delete tmp;
	}
}
```

## Очередь - Queue

Очередь - линейный список, работающий по принципу `FIFO` (Первым вошёл - первый вышел).

Операции:
- `nullQueue` - обнуление очереди
- `empty` - проверка очереди на пустоту
- `add` (`enqueue`) - добавление элемента в очередь
- `del` (`dequeue`) - удаление элемента из очереди

### Реализация очереди массивом

```cpp
class Queue {
private:
	struct Node {
		int data;
		Node* next;
	}
	Node *head, *tail;
public:
	Queue() { head = NULL; tail = NULL; }
	bool empty() const;
	void enqueue(int value);
	int dequeue();
	void nullQueue();
}

bool Queue::empty() const { return head == NULL; }
void Queue::enqueue() {
	if (empty()) {
		head = new Node;
		head->data = value;
		head->next = NULL;
		tail = head;
	} else {
		tail->next = new Node;
		tail = tail->next;
		tail->data = value;
		tail->next = NULL;
	}
}
int Queue::dequeue() {
	if (empty()) return 0;

	int d = head->data;
	Node *tmp = head;
	head = head->next;
	delete tmp;
	return d;
}
void Queue::nullQueue() {
	Node *tmp;
	while (!empty()) {
		tmp = head;
		head=head->next;
		delete tmp;
	}
}
```
