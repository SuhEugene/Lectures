# Метод полного перебора

Многие задачи заключаются в выборе одного или нескольких вариантов из набора дискретных данных. Один из самых простых способов решения таких задач - перебрать все возможные варианты и выбрать из них необходимый.

Главное достоинство такого метода - гарантированно полное решение задачи.  
Основной недостаток - большое время выполнения алгоритма при увеличении количества исходных данных.

## Перебор циклами

Главный недостаток перебора циклами заключается в том что можно заранее не знать сколько циклов вкладывать друг в друга. То есть их количество может зависеть от длины исходных данных.

##### Пример: Найти количество счастливых автобусных билетов

```cpp
int cnt = 0;
for (int a = 0; a <= 9; a++)
  for (int b = 0; b <= 9; b++)
    for (int c = 0; c <= 9; c++)
      for (int d = 0; d <= 9; d++)
        for (int e = 0; e <= 9; e++)
          for (int f = 0; f <= 9; f++)
            if ((a+b+c) == (d+e+f))
              cnt++;
```

## Полный P-ичный перебор

Каждому перебираемому элементу ставится в соответствии цифра в P-ичной системе счисления. Предполагается, что каждый элемент может находиться в $P$ различных состояниях. Тогда перебор всех вариантов потребует $P^n$ итераций, где $n$ - количество исходных данных.

Дано $N$ объектов, каждому из которых поставлена в соответствии некоторая стоимость. Разделить объекты на две группы так, чтобы разность стоимостей между группами была минимальной.

Данная задача решается полным двоичным перебором. За каждым объектом закрепляется двоичная цифра:
- `0` - объект попадает в первую группу
- `1` - объект попадает во вторую группу

Перебор сводится к просмотру всех чисел разрядности $N$ в двоичной системе счисления.

```cpp
void plus(int *m, int n) {
  int i = n;
  while (m[i] == 1)
    m[i--] = 0;
  m[i] = 1;
}
  
int main() {
  const int n = 5;
  int min = 15;
  int m[n+1] = {0, 1, 2, 3, 4, 5},
      bin[n+1] = {0, 0, 0, 0, 0, 0};
  while (bin[0] == 0) {
    int s1 = 0, s2 = 0;
    for (int i = 1; i <= n; i++)
      if (bin[i] == 0) s1 += m[i];
      else s2 += m[i];
  
    if (abs(s1 - s2) < min)
      min = abs(s1 - s2);
  
    plus(bin, n);
  }
  return 0;
}
```

## Рекурсивный перебор

Дан квадратный числовой массив

Найти такой путь из левого верхнего угла массива в правый нижний, чтобы сумма чисел по данному пути была максимальной.

Из каждого элемента массива допустимо двигаться только вправо или вниз.

Идея заключается в следующем: из каждой клетки массива, если это возможно, будем пытаться идти сначала вниз, потом вправо.

Когда дойдём до правого нижнего элемента массива, найденную по пути сумму сравним с максимальной и если найденная оказалась больше, запомним её в максимум.

```cpp
void poisk (int **m, int n, int i, int j, int s, int _max) {
	s += m[i][j];
	if (i == n-1 && j == n-1 && s > _max)
		_max = s;
	if (i < n-1) poisk(m, n, i+1, j, s, _max);
	if (j < n-1) poisk(m, n, i, j+1, s, _max);
}
```

## Динамическое программирование

Данный метод был описан в 1960х с целью ускорения решения многих задач выбора.

Суть метода в следующем: большая задача делится на подзадачи. В начале, решается подзадача минимального размера, далее, на её основе - подзадача следующего размера, и так далее, пока не будет решена искомая задача, размера $n$.  

При этом должно выполняться условие: предыдущие подзадачи не пересчитываются. То, что хорошо локально, будет хорошо и глобально для большой задачи.

На каждом шаге пересчёта выбор варианта производится в соответствии с так называемым принципом оптимальности.

### Пример 1

Предыдущий пример можно решить динамическим программированием. Для этого заводится ещё один массив размером $n \times n$.

Ясно, что если массив $a$ имеет размер $1 \times 1$ (минимальная подзадача), то набранная сумма будет равна элементу `a[0][0]` - занесём её в `b[0][0]`.

Если от элемента `a[0][0]` станем двигаться вправо, то сумма изменится на `b[0][0] + a[0][1]`. И так можно продолжить для всей первой строки и первого столбца массива.

Для всех остальных элементов: `b[i][j] = max(b[i-1][j], b[i][j-1]) + a[i][j]` - это "принцип оптимальности".

В элементе массива `b[n-1][n-1]` получим значение искомой суммы.

Сам путь можно найти двигаясь от элемента `b[n-1][n-1]` к элементу `b[0][0]` по "жадному" алгоритму.

### Пример 2

##### Задача о министерстве.

Вовочке нужно подписать документ у министра. Министр подписывает бумагу, если на ней имеется подпись любого работника с последнего этажа министерства.

Каждый работник на каждом этаже сидит в отдельном кабинете и ставит подпись только в том случае, если на бумаге уже стоит подпись работника либо из кабинета под ним, либо из одного из соседних кабинетов. На первом этаже бумагу сразу подписывает любой работник.

За свою подпись каждый работник берёт некоторую сумму. Известны суммы, которые берёт каждый работник в каждом кабинете.

Найти такой путь Вовочки по министерству, чтобы сумма была минимальной.

Количество этажей $1 \le n \le 100$.

##### Решение

Для решения можно использовать три двумерных массива.

В массиве $a$ будем хранить суммы, которые берут клерки в каждом кабинете.

Массив $b$ - это расчёт лучшего значения суммы для каждого кабинета. Рассчёт будет вестись по формуле:  
`b[i][j] = min(a[i][j] + b[i-1][j], a[i][j] + b[i][j-1], a[i][j] + b[i][j+1])`   
по принципу оптимальности.

В массиве $c$ будем отмечать откуда мы пришли в каждый кабинет:
- Снизу - 0
- Справа - -1
- Слева - 1

При реализации двумерные массивы $a$ и $b$ можно заменить на одномерные, считывая в $a$ значения текущего этажа и просчитывая $b$ для вновь считанного этажа на основании уже имеющихся в $b$ данных.

##### Программа

```cpp
int currentfloor[M];
int bestfloor[M];
int direction[N][M];
ifstream f("input.txt");
int n, m;
f >> n >> m;
for (int i = 0; i < m; i++)
	bestfloor[i] = 0;``
for (int i = 0; i < n; i++) {
	for (int j = 0; j < m; j++)
		f >> currentfloor[j];
		bestfloor[j] += currentfloor[j];
		direction[i][j] = 0;
	}
	for (int j = 1; j < m; j++)
		if (bestfloor[j-1] + currentfloor[j] < bestfloor[j]) {
			bestfloor[j] = bestfloor[j-1] + currentfloor[j];
			direction[i][j] = -1;
		}
		if (bestfloor[j+1] + currentfloor[j] < bestfloor[j]) {
			bestfloor[j] = bestfloor[j+1] + currentfloor[j];
			direction[i][j] = 1;
		}
	}
}
```


### Пример 3

##### Задача о рюкзаке

Имеется $n$ видов объектов массами $m_1$, $m_2$, ..., $m_n$ и стоимостями $s_1$, $s_2$,, ..., $s_n$. Объектов каждого вида неограниченное количество.

Также имеется рюкзак, который может вместить по массе не более $M$ единиц.

Требуется узнать сколько предметов каждого вида нужно положить в рюкзак, чтобы суммарная стоимость предметов в рюкзаке была наибольшей.

Все величины $m_i$, $s_i$ и $M$ - целые числа.

##### Решение

Будем заполнять рюкзаки вместимостью 0, 1, ..., $M$ объектами первого вида, высчитывая при этом стоимость каждого рюкзака.

На следующем шаге в каждый из рюкзаков будем пытаться поместить объекты второго вида в количестве 0, 1, ..., $M$, при этом может остаться ещё какая-то масса, которую рюкзак выдержит. Её надо заполнить предметами первого вида, а эта стоимость уже просчитана на предыдущем шаге. Осталось из всех вариантов загрузки предметов второго вида выбрать наилучший и запомнить его. И так далее до загрузки рюкзака вместимостью $M$ предметами $n$-го вида.