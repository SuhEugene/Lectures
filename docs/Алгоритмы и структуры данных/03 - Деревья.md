# Деревья

Деревья в классике алгоритмизации растут не снизу вверх, как мы привыкли, а сверху вниз.

**Дерево** - это совокупность элементов, называемых узлами, один из которых определён как корень, и "родительских" отношений, образующих иерархическую структуру дерева.

**Рекурсивное определение:**
1. Один узел является деревом. Он же является его корнем.
2. Пусть $n$ - узел, $T_1$, $T_2$, ..., $T_k$ - деревья, с корнями $n_1$, $n_2$, ..., $n_k$ соответственно. Можно построить новое дерево, сделав $n$ родителем узлов $n_1$, $n_2$, ..., $n_k$. В этом дереве $n$ - корень, $T_1$, $T_2$, .., $T_k$ - поддеревья этого корня, $n_1$, $n_2$, ..., $n_k$ - прямые потомки (сыновья) узла $n$.

**Путём** из узла $n_1$ в узел $n_k$ называется последовательность вершин дерева $n_1$, $n_2$, ..., $n_k$, где для всех $i < k$ и $i \geq 1$ узел $n_i$ является родительским узлом для $n_{i-1}$.  
**Длиной пути** называется число на единицу меньшее количества узлов, составляющих этот путь.

Если существует путь из узла $a$ в узел $b$, то
- Узел $a$ - предок узла $b$.
- Узел $b$ - потомок узла $a$.

Считается что любой узел является одновременно предком и потомком самому себе. Таким образом корень дерева - узел не имеющий других предков.

Узел, не имеющий других потомков, кроме себя называется **листом** или терминальной вершиной дерева.

**Высотой узла** дерева называется длина самого длинного пути от этого узла до некоторого листа.  
Высота дерева совпадает с высотой корня.

**Глубиной узла** называется длина пути от корня до этого узла.

Дерево не имеющее ни одного узла называется **нулевым деревом**.


#### Пример дерева

![Пример дерева.png](../%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B0.png#)

Корень дерева - $A$.  
Листья дерева: $E$, $F$, $J$, $K$, $H$, $I$.  
Высота дерева: $3$.

## Способы обхода деревьев

**Способ обхода** - это упорядочение узлов дерева по некоторому признаку/правилу.
### Классический

Обычно используют три способа обхода: прямой, обратный, симметричный.

**Правила обхода:**
- Если дерево $T$ является нулевым, то в список обхода заносится пустая запись.
- Если дерево $T$ состоит из одного узла, то в список обхода заносится этот узел.
- Пусть $T$ - дерево с корнем $n$ и поддеревьями $T_1$, $T_2$, ..., $T_k$.  
	Тогда для различных способов обхода имеем:
	1. При **прямом обходе** сначала посещается корень $n$, затем поддеревья $T_1$, $T_2$, ..., $T_k$ также в прямом порядке.  
		Для дерева из примера, порядок: $A,B,E,F,C,G,J,K,D,H,I$.
	2. При **обратном обходе** сначала в обратном порядке обходится поддерево $T_1$, затем $T_2$, ..., $T_k$ также в обратном порядке. Последним посещается корень $n$.  
		Порядок дерева из примера: $E,F,B,J,K,G,C,H,I,D,A$.
	3. При **симметричном обходе** сначала в симметричном порядке обходится поддерево $T_1$, затем корень $n$, после чего - поддеревья $T_2$, ..., $T_k$ также в симметричном порядке.  
		(Лево, корень, остальное)  
		Порядок примера: $E,B,F,A,C,J,G,K,H,D,I$.

## Бинарные деревья

Дерево, у каждого узла которого может быть не более двух прямых потомков называется бинарным или двоичным деревом.

Бинарное дерево называется **сбалансированным**, если высоты левого и правого поддеревьев любого узла дерева отличаются друг от друга не более, чем на единицу.  
**Идеально сбалансированное** дерево - разность высот для любого из узлов равна нулю.

### Способы представления бинарных деревьев

#### Одномерный массив

Корень дерева - нулевой элемент массива.
Левый потомок корня - первый элемент.
Правый потомок корня - второй элемент.
...
Потомки элемента $i$ - хранятся под номерами:
- $2i+1$ - левый
- $2i+2$ - правый.

#### Пример:
![Небольшое дерево.png](../%D0%9D%D0%B5%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE.png#)

Хранится в виде:

| 0   | 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- | --- |
| $A$ | $B$ | $C$ | $D$ | $E$ | $F$   |

### Динамическая структура данных

```cpp
strcut Node {
	int data;
	Node *left, *right;
}
```
![Пример ноды дерева структурой.png](../%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%20%D0%BD%D0%BE%D0%B4%D1%8B%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B0%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BE%D0%B9.png#)
```cpp
void create(Node *&node, int n) {
	if (node != NULL)
		return;
	node = new Node;
	node->data = n;
	node->left = NULL;
	node->right = NULL;
}

void print(Node *node) {
	if (node == NULL)
		return;
	std::cout << node->data << " "
	print(node->left);
	print(node->right);
}
```

## Дерево Хаффмана

Каждый узел дерева Хаффмана будет состоять из пяти полей: символ, вероятность его вхождения, указатели на левое и правое поддеревья, а также указатель на родительский узел. Этот указатель нужен для того, чтобы быстро найти код любого символа.

Заведём два одномерных массива: `trees`, где будем собирать дерево Хаффмана, пока оно не останется одно, и `symbols` - указатели на все символы для быстрого нахождения кода.

```cpp
class HaffmanTree {
private:
	struct Node {
		double p;
		char c;
		Node *left, *right, *parent;
	};
	Node *trees[256], *symbols[256];
	int size;
public:
	HaffmanTree(int size) { this->size = size; }
	void read() {
		for (int i = 0; i < size; i++) {
			trees[i] = new Node;
			symbols[i] = trees[i];
			std::cout << "Symbol: ";
			std::cin >> trees[i]->c;
			std::cout << "Probability: ";
			std::cin >> trees[i]->p;
			trees[i]->left = NULL;
			trees[i]->right = NULL;
			trees[i]->parent = NULL;
		}
	}
	void printCode() {
		if (size == 1) {
			std::cout << symbols[0]->c << " - " << 0 << std::endl;
			return;
		}
		for (int i = 0; i < size; i++) {
			Node *tmp = symbols[i];
			string code = "";
			while (tmp->parent != NULL) {
				if (tmp->parent->left == tmp)
					code = "0" + code;
				else
					code = "1" + code;
				tmp = tmp->parent;
			}
		}
		
	}
	void makeTree (int col) {
		if (col <= 1)
			return;
		double minp1, minp2 = 1;
		int n1, n2 = 0;
		for (int i = 0; i < size; i++)
			if (trees[i] != NULL && trees[i]->p < minp1) {
				minp1 = trees[i]->p;
				n2 = i;
			}
		for (int i = 0; i < size; i++)
			if (trees[i] != NULL && trees[i]->p < minp2 && i != n1) {
				minp1 = trees[i]->p;
				n2 = i;
			}
		Node *tmp = new Node;
		tmp->left = trees[n1];
		tmp->right = trees[n2];
		treen[n1]->parent = tmp;
		trees[n2]-> parent = tmp;
		tmp->p = trees[n1]->p + trees[n2]->p;
		trees[n1] = tmp;
		trees[n2] = NULL;
		makeTree(col-1);
	}
};
```
