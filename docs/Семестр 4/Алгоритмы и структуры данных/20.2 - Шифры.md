# Шифры

## Шифры гаммирования

Пример: Шифр Вернама

Плюсы:

- Простота шифрования
- Невозможность расшифровать открытый текст не зная гаммы, если длина гаммы >= длины открытого текста

Минусы:

- Если злоумышленнику известна часть открытого текста и соответствующий зашифрованный - находится часть гаммы.

## Симметричные блочные шифры

Для обозначения мы будем использовать *специальные обозначения, которые мне перерисовывать и фоткать лень*.

Во всех формулах под параметром $V$ обычно понимают:

1. Некоторую константу
2. Часть шифруемого блока
3. Материал ключа

S-box - табличная подстановка. Одна из биективных математических функций шифрации.

Создаём табличку из 16 ячеек. Заполняем случайными 4битными числами. Берём каждый 4битный блок кода и используем его число как id для поиска в таблице новой замены.

### Сеть Фейштеля

![Pasted image 20240507153827.png](../../Pasted%20image%2020240507153827.png#)

Сеть Фейштеля является классической схемой симметричного шифрования. 

Исходный блок делится на две части $x_1$ и $x_2$. К части $x_1$ применяется образующая функция $f$, результат с помощью операции $XOR$ накладывается на часть $x_2$ и ветви меняются местами. Подобное действие называется раундом сети. Обычно количество раундов 8-32. В конце алгоритма ветви просто меняются местами.

Параметры $V_1, V_2, ..., V_r$ обычно являются материалами ключа.

Криптостойкость схемы нелинейно возрастает с увеличением числа раундов.

Размер блока как правило от 64 до 256 бит.

Поскольку наложение одной ветви на другую производится с помощью операции XOR, а она обратима при повторном использовании, то ту же самую сеть можно использовать для дешифрования, лишь изменив порядок параметров $V_i$ на обратный.

#### Пример на C++

```cpp
int f(int x1, int v) { return x1 + v; }

struct OutData { int x1, x2; };
OutData encrypt(int x1, int x2, int *key, int r) {
	for (int i = 0; i < r; i++) {
		x2 = x2 ^ f(x1, key[i]);
		swap(x1, x2);
	}
	swap(x1, x2);
	return { x1, x2 };
}

OutData decrypt(int x1, int x2, int *key, int r) {
	for (int i = r-1; i >= 0; i--) {
		x2 = x2 ^ f(x1, key[i]);
		swap(x1, x2);
	}
	swap(x1, x2);
	return { x1, x2 };
}

int main() {
	int x1 = 2000000000, x2 = 1;
	int key[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };

	OutData enc = encrypt(x1, x2, key, 8);
	OutData dec = decrypt(enc.x1, enc.x2, key, 8);
	cout << "In: " << x1 << " " << x2 << endl;
	cout << "Enc: " << enc.x1 << " " << enc.x2 << endl;
	cout << "Dec: " << dec.x1 << " " << dec.x2 << endl;

	return 0;
}
```


## Алгоритм DES - Data Encryption Standart

В 1977 году был предложен, а в 1980 году принят как стандарт симметричного шифрования США алгоритм DES.

Сам алгоритм представляет классическую сеть Фейштеля из 16 раундов с единственным добавлением так называемого начального и конечного "забеливания" - перемешивания бит исходного блока перед началом работы сети и конечного блока после работы сети. Размер шифруемого блока: 64 бита. Размер ключа: 56 бит. Образующая функция:

1. Поступают 32 бита
2. Расширяются до 48 бит
3. К ним прибавляется с помощью операции $XOR$ материал ключа.
4. 48 бит делятся на группы по 6 бит.
5. Каждая из них используется в S-box'е с выходом 4 бита.
6. На выходе 32 бита.


![Pasted image 20240507162330.png](../../Pasted%20image%2020240507162330.png#)

## Алгоритм 3DES

$DES(k_3, DES(k_2, DES(k_1, M)))$

Сообщение $M$ шифруется через $DES$ сначала ключом $k_1$, затем - $k_2$, и после - $k_3$.

Самая популярная разновидность 3DES - это DES-EDE3 - 3 ключа, первый шифрует, второй расшифровывает, третий вновь шифрует.


## ГОСТ 28147-89

Ключ: 256 бит. Раунды: 32.

Образующая функция:

![Pasted image 20240507163458.png](../../Pasted%20image%2020240507163458.png#)


## Ассиметричная криптография

Ассиметричная криптография даёт также симпатичное решение цифровой подписи документов.

Цифровая подпись - это некоторый идентификатор, который подтверждает целостность пришедшего документа, а также его авторство.

Будем находить от открытого текста хэш-значение - число, имеющее определённый размер, и уникально определяющее открытый текст. При этом это значение должно отвечать как минимум двум требованиям:

- Размер хэша в битах для любого текста должен быть один и тот же
- При изменении текста на 1 бит идеальный хэш инвертирует половину произвольных бит.

Стандартный размер хэша: 64, 128, 256 бит

Теоретически можно подобрать текст с тем же самым хэшем, что и у шифруемого текста, но это придётся делать полным перебором и полученный текст вряд ли будет осмысленным.

# Генерация случайных чисел

Генераторы случайных чисел:

- Автоматические
- Автоматизированные

Генераторы псевдо-случайных чисел:

- Общего назначения
- Криптогенераторы

