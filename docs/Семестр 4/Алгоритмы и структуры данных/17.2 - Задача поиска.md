# Задача поиска

Имеется последовательность объектов (записей), требуется отыскать объект по некоторому значению ключа, либо сказать что объект отсутствует.

## Последовательный поиск

Все элементы последовательности просматриваются один за другим, пока искомый не будет найден или не будет просмотрена вся последовательность.

Сложность: $O(n)$.

```cpp
int straightSearch(int *arr, int n, int key) {
	int i = 0;
	while (i < n && arr[i] != key) i++;
	if (i < n) return i;
	return -1;
}
```

В цикле while первое условие к поиску элемента никакого отношения не имеет. Чтобы его избежать опишем массив на один элемент больше, чем его реальный размер и при поиске на последнее $n$-е место в массиве будем ставить искомый ключ. Этот ключ будет выступать как барьер.

## Бинарный поиск

Данный поиск проводится на **отсортированной последовательности** так называемым методом половинного деления.

Алгоритм:

- Находим элемент, находящийся в середине массива (с индексом $n/2$) и сравниваем искомый ключ с данным элементом.
- Если ключ равен искомому - поиск закончен. Если меньше среднего - поиск продолжаем в левой половине, если больше - в правой.

Сложность алгоритма: $O(\log_2(n))$

```cpp
int binarySearch(int *arr, int n, int key) {
	int left = 0, right = n - 1;
	int i = (left + right) / 2;
	while (left <= right && key != arr[i]) {
		if (key < arr[i]) right = i - 1;
		if (key > arr[i]) left = i + 1;
		i = (left + right) / 2;
	}
	if (left <= right) return i;
	return -1;
}
```


## Дерево поиска

Алгоритм:

- Первый элемент последовательности становится корнем **бинарного** дерева.
- Каждый следующий добавляется по правилу: 
	- Если элемент меньше корня - налево.
	- Если элемент больше корня - направо.

```
8, 4, 55, 66, 4, 123, 12, 666

      8
  44      55
4       12  66
               123
                  666
```

Поиск по такому дереву происходит пойдёт сравнением искомого ключа со значением в узле и дальнейшим проходом налево, либо направо в зависимости от того, меньше искомый ключ значения в узле или больше.

**При симметричном обходе дерева, выводится отсортированная последовательность значений.**

Если дерево поиска получилось сбалансированное, то сложность поиска по нему: $O(\log_2(n))$.

В худшем случае дерево может выродиться в линейный список и сложность будет $O(n)$.

```cpp
struct node {
	string word;
	int count;
	node *left, *right;
};

void insert(node *root, string word) {
	if (root == NULL) {
		root = new node;
		root->word = word;
		root->count = 1;
		root->left = NULL;
		root->right = NULL;
	}
	else if (word < root->word)
		insert(root->left, word);
	else if (word > root->word)
		insert(root->right, word);
	else
		root->count++;
}
```

## АВЛ-деревья

Чтобы дерево поиска не выродилось в линейный список, хорошо бы было его поддерживать в сбалансированном виде. Красивое решение было предложено в 1962 году советскими математиками Адельсом-Вельским и Ландисом.

Их метод требует всего двух дополнительных битов на узел для поддержания дерева поиска в сбалансированном состоянии всегда.

> Изобразим пример сбалансированного дерева, на котором для каждого узла отметим фактор сбалансированности в зависимости от разности высот правого и левого поддеревьев узла.
> 
> Это сбалансированное дерево имеет высоту 4, а также 8 листьев.
> 
> Дерево останется сбалансированным, если добавить ещё один узел после узлов 2, 5, 6. В остальных случаях потребуется дополнительная корректировка.

Проблема возникает в двух случаях:

1. Одна из сторон становится больше с той же стороны. Модификатор становится не +1 или -1, а +2 или -2, что значит одна из сторон имеет вес больше.  
   Случай, например, когда у ноды справа появляется ещё одна нода справа.
   Решением является перемещение текущей ноды выше на один уровень.
2. Одна из сторон становится больше с другой стороны.
   Случай, например, когда у ноды справа появляется нода слева.
   Тогда для решения нужно создать новую ноду, корневую ноду поддерева отправить налево, а её зависимую - направо. К . ноде поддерева крепится требуемая.

Два других "неприятных" случая могут быть получены из указанных при зеркальном отражении относительно вертикальной оси.

Стоит заметить, что новые деревья имеют ту же высоту что и до вставки элемента. Это значит, что всё дерево поиска, находящееся выше корневого узла разбалансировки остаётся в прежнем сбалансированном виде.

## Красно-чёрные деревья

**Красно-чёрные деревья** - бинарные деревья поиска, у которых для каждой вершины добавляется дополнительное свойство: вершина является чёрной или красной.

Требуется выполнение свойств:

- Корень дерева - чёрный
- У каждой красной вершины потомки - чёрные
- В двух любых ветвях от корня до листа количество содержащихся чёрных вершин равно

![Pasted image 20240402162407.png](../../Pasted%20image%2020240402162407.png#)

Чтобы всегда выполнялось третье условие красно-чёрного дерева, при реализации считается, что все листья дерева - чёрные.

Математически подсчитано, что в дереве, содержащем $N$ узлов, $\log_2{N} < h <= 2\log_2{(N+1)}$

Структура для КЧД выглядит просто:

```cpp
struct RBTree {
	bool color;
	int key;
	RBTree *parent;
	RBTree *left, *right;
}
```

Вставка элемента:
1. Случай 1. Дядя вершины x - красный.  
   Перекрашиваем родителя, дядю и деда, а затем проверяем выше, если бы x был дедом.
2. Случай 2. Дядя вершины x - чёрный, x и родитель - левые потомки.
   Брат x становится на место родителя x, а родитель x становится родителем деда. Родитель x становится чёрным, а дед становится красным.
3. Случай 3. Дядя вершины x - чёрный, но x - правый потомок, а родитель - левый потомок.
   x сохраняет своего правого потомка, а левым потомком становится его родитель.