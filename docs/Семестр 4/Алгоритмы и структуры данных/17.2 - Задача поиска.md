# Задача поиска

Имеется последовательность объектов (записей), требуется отыскать объект по некоторому значению ключа, либо сказать что объект отсутствует.

## Последовательный поиск

Все элементы последовательности просматриваются один за другим, пока искомый не будет найден или не будет просмотрена вся последовательность.

Сложность: $O(n)$.

```cpp
int straightSearch(int *arr, int n, int key) {
	int i = 0;
	while (i < n && arr[i] != key) i++;
	if (i < n) return i;
	return -1;
}
```

В цикле while первое условие к поиску элемента никакого отношения не имеет. Чтобы его избежать опишем массив на один элемент больше, чем его реальный размер и при поиске на последнее $n$-е место в массиве будем ставить искомый ключ. Этот ключ будет выступать как барьер.

## Бинарный поиск

Данный поиск проводится на **отсортированной последовательности** так называемым методом половинного деления.

Алгоритм:

- Находим элемент, находящийся в середине массива (с индексом $n/2$) и сравниваем искомый ключ с данным элементом.
- Если ключ равен искомому - поиск закончен. Если меньше среднего - поиск продолжаем в левой половине, если больше - в правой.

Сложность алгоритма: $O(\log_2(n))$

```cpp
int binarySearch(int *arr, int n, int key) {
	int left = 0, right = n - 1;
	int i = (left + right) / 2;
	while (left <= right && key != arr[i]) {
		if (key < arr[i]) right = i - 1;
		if (key > arr[i]) left = i + 1;
		i = (left + right) / 2;
	}
	if (left <= right) return i;
	return -1;
}
```


## Дерево поиска

Алгоритм:

- Первый элемент последовательности становится корнем **бинарного** дерева.
- Каждый следующий добавляется по правилу: 
	- Если элемент меньше корня - налево.
	- Если элемент больше корня - направо.

```
8, 4, 55, 66, 4, 123, 12, 666

      8
  44      55
4       12  66
               123
                  666
```

Поиск по такому дереву происходит пойдёт сравнением искомого ключа со значением в узле и дальнейшим проходом налево, либо направо в зависимости от того, меньше искомый ключ значения в узле или больше.

**При симметричном обходе дерева, выводится отсортированная последовательность значений.**

Если дерево поиска получилось сбалансированное, то сложность поиска по нему: $O(\log_2(n))$.

В худшем случае дерево может выродиться в линейный список и сложность будет $O(n)$.

```cpp
struct node {
	string word;
	int count;
	node *left, *right;
};

void insert(node *root, string word) {
	if (root == NULL) {
		root = new node;
		root->word = word;
		root->count = 1;
		root->left = NULL;
		root->right = NULL;
	}
	else if (word < root->word)
		insert(root->left, word);
	else if (word > root->word)
		insert(root->right, word);
	else
		root->count++;
}
```

## АВЛ-деревья

Чтобы дерево поиска не выродилось в линейный список, хорошо бы было его поддерживать в сбалансированном виде. Красивое решение было предложено в 1962 году советскими математиками Адельсом-Вельским и Ландисом.

Их метод требует всего двух дополнительных битов на узел для поддержания дерева поиска в сбалансированном состоянии всегда.

> Изобразим пример сбалансированного дерева, на котором для каждого узла отметим фактор сбалансированности в зависимости от разности высот правого и левого поддеревьев узла.
> 
> Это сбалансированное дерево имеет высоту 4, а также 8 листьев.
> 
> Дерево останется сбалансированным, если добавить ещё один узел после узлов 2, 5, 6. В остальных случаях потребуется дополнительная корректировка.

Проблема возникает в двух случаях:

1. Одна из сторон становится больше с той же стороны. Модификатор становится не +1 или -1, а +2 или -2, что значит одна из сторон имеет вес больше.  
   Случай, например, когда у ноды справа появляется ещё одна нода справа.
   Решением является перемещение текущей ноды выше на один уровень.
2. Одна из сторон становится больше с другой стороны.
   Случай, например, когда у ноды справа появляется нода слева.
   Тогда для решения нужно создать новую ноду, корневую ноду поддерева отправить налево, а её зависимую - направо. К . ноде поддерева крепится требуемая.

Два других "неприятных" случая могут быть получены из указанных при зеркальном отражении относительно вертикальной оси.

Стоит заметить, что новые деревья имеют ту же высоту что и до вставки элемента. Это значит, что всё дерево поиска, находящееся выше корневого узла разбалансировки остаётся в прежнем сбалансированном виде.

## Красно-чёрные деревья

**Красно-чёрные деревья** - бинарные деревья поиска, у которых для каждой вершины добавляется дополнительное свойство: вершина является чёрной или красной.

Требуется выполнение свойств:

- Корень дерева - чёрный
- У каждой красной вершины потомки - чёрные
- В двух любых ветвях от корня до листа количество содержащихся чёрных вершин равно

![Pasted image 20240402162407.png](../../Pasted%20image%2020240402162407.png#)

Чтобы всегда выполнялось третье условие красно-чёрного дерева, при реализации считается, что все листья дерева - чёрные.

Математически подсчитано, что в дереве, содержащем $N$ узлов, $\log_2{N} < h <= 2\log_2{(N+1)}$

Структура для КЧД выглядит просто:

```cpp
struct RBTree {
	bool color;
	int key;
	RBTree *parent;
	RBTree *left, *right;
}
```

Вставка элемента:
1. Случай 1. Дядя вершины x - красный.  
   Перекрашиваем родителя, дядю и деда, а затем проверяем выше, если бы x был дедом.
2. Случай 2. Дядя вершины x - чёрный, x и родитель - левые потомки.
   Брат x становится на место родителя x, а родитель x становится родителем деда. Родитель x становится чёрным, а дед становится красным.
3. Случай 3. Дядя вершины x - чёрный, но x - правый потомок, а родитель - левый потомок.
   x сохраняет своего правого потомка, а левым потомком становится его родитель.

## B-деревья

В каждой вершине B-деревьев может содержаться несколько ключей. Высота дерева определяется как максимальное количество вершин в ветви.

Будем рассматривать случай, когда все ключи различны. B-дерево степени $n$ определяется следующим образом:

1. Каждая вершина, кроме корня, содержит от $n-1$ до $2n - 1$ ключей и от $n$ до $2n$ ссылок на узлы-потомки. Корень дерева содержит не более $2n-1$ ключей и $2n$ ссылок.
2. B-дерево идеально сбалансировано и длина каждой ветви одинакова.
3. Элементы в каждой вершине упорядочены по возрастанию.
4. Если в вершине находится $k$ элементов, то в ней $k+1$ ссылка на потомков.
5. Элементы в вершине и ссылки сопоставляются так:
	- Про первую ссылку говорят, что она находится до первого элемента.
	- Последняя - после последнего.
	- Все остальные - между парами элементов.
6. Если узел является потомком от узла с ссылкой, пришедшей от пары $(a, b)$, то все значения в узле больше $a$, меньше $b$.

Высота B-дерева $h \leq \log_n{(N+1)}/2 + 1$, где $n$ - степень дерева, $N$ - количество элементов (ключей).

Поиск по такому дереву происходит, как в обычном дереве поиска, но в каждом узле необходимо найти соответствующую ссылку.


## Хэширование

Данный метод требует фиксированного, обычно малого, времени на выполнение операции поиска.

Выделяют два вида хеширования:

- Открытое, внешнее или расширенное
- Закрытое, внутреннее или прямое

Термин "хэширование" произошёл от глагола "to hash" - рубить, измельчать, перемешивать.

Всё множество значений ключа разбивается на $B$ классов, пронумерованных от $0$ до $B-1$.

Далее строится хэш-функция $h$, что для любого элемента $x$ из исходного множества ключей, функция $h(x)$ принимает целочисленное значение из отрезка от $0$ до $B-1$. Это значение и есть номер класса, в который помещается элемент $x$.

### Открытое хэширование

$B$ указателей, каждый из которых хранит адрес списка элементов с одним и тем же хэшем, равным индексу ячейки.

Ситуация, когда два элемента имеют один и тот же хэш называется коллизией. Размер таблицы $B$ и вид хэш-функции $h$ обычно выбираются такими, чтобы количество коллизий сводилось к минимуму.

> В Java для ячеек с большим количеством коллизий вектор превращается в красно-чёрное дерево


#### Пример

Ключи: `13, 19, 3, 52, 59, 14, 64, 69, 34`

$B = 5$  $h(x) = x\ \%\ B$

![Pasted image 20240409161843.png](../../Pasted%20image%2020240409161843.png#)

Поиск по такой таблице происходит вычислением значения $h(x)$ и прохождением по списку сегмента $x$. 

Самые большие проблемы происходят в 4м сегменте из-за большого количества коллизий.

> Для лабораторной:  
> $h(x) = (a\times x+c)\ \%\ B$

### Закрытое хэширование

При закрытом хэшировании в таблице сегментов хранятся сами элементы, а не указатели. Поэтому в каждом сегменте может находиться лишь один элемент, а это значит, что в закрытой хэш-таблице не может быть размещено более $B$ элементов, где $B$ - размер таблицы.

Кроме того, возникают проблемы в случае коллизии. На помощью приходят дополнительные хэш-функции. Если на функции $h_0(x)$ произошла коллизия, к объекту применяются функции $h_1(x)$, $h_2(x)$ и так далее, пока не будет найдена свободная ячейка.

Вид функции для повторного кэширования может быть например такой: $h_i(x) = (h_0(x)+i)\ \%\ B$.

При закрытом хэшировании возникает ещё одно проблема - удаление элемента. Сегмент, из которого удалён элемент с одной стороны должен быть пустым, чтобы в него можно было поместить новый, а с другой - не совсем пустым, чтобы не потерять элементы с тем же хэшем, расположенные из-за коллизии после удалённой ячейки.

Поэтому в закрытой хэш-таблице помимо хэшей приходится держать ещё два значения:

- Пустая ячейка - в неё производится новая запись и до неё поиск элементов.
- Удалённая ячейка - в неё также возможна запись, но поиск элементов в случае коллизии продолжается дальше.

Формула $h_i(x) = (h_0(x)+i)\ \%\ B$ является не очень хорошей с точки зрения разрешения коллизий, поэтому рекомендуют использовать другие варианты:

- $h_i(x) = (h_0(x)+C_i)\ \%\ B$, где на каждом $i$-м шаге $C_i$ - новая константа, взаимно простая с $B$.
- $h_i(x) = (h_0(x)+d_i)\ \%\ B$, где $d_1$, $d_2$, $d_3$, ..., $d_{B-1}$ - некоторая перестановка чисел: $1$, $2$, $3$, ..., $B-1$.