# Задача поиска

Имеется последовательность объектов (записей), требуется отыскать объект по некоторому значению ключа, либо сказать что объект отсутствует.

## Последовательный поиск

Все элементы последовательности просматриваются один за другим, пока искомый не будет найден или не будет просмотрена вся последовательность.

Сложность: $O(n)$.

```cpp
int straightSearch(int *arr, int n, int key) {
	int i = 0;
	while (i < n && arr[i] != key) i++;
	if (i < n) return i;
	return -1;
}
```

В цикле while первое условие к поиску элемента никакого отношения не имеет. Чтобы его избежать опишем массив на один элемент больше, чем его реальный размер и при поиске на последнее $n$-е место в массиве будем ставить искомый ключ. Этот ключ будет выступать как барьер.

## Бинарный поиск

Данный поиск проводится на **отсортированной последовательности** так называемым методом половинного деления.

Алгоритм:

- Находим элемент, находящийся в середине массива (с индексом $n/2$) и сравниваем искомый ключ с данным элементом.
- Если ключ равен искомому - поиск закончен. Если меньше среднего - поиск продолжаем в левой половине, если больше - в правой.

Сложность алгоритма: $O(n \log_2(n))$

```cpp
int binarySearch(int *arr, int n, int key) {
	int left = 0, right = n - 1;
	int i = (left + right) / 2;
	while (left <= right && key != arr[i]) {
		if (key < arr[i]) right = i - 1;
		if (key > arr[i]) left = i + 1;
		i = (left + right) / 2;
	}
	if (left <= right) return i;
	return -1;
}
```


## Дерево поиска

Алгоритм:

- Первый элемент последовательности становится корнем **бинарного** дерева.
- Каждый следующий добавляется по правилу: 
	- Если элемент меньше корня - налево.
	- Если элемент больше корня - направо.

```
8, 4, 55, 66, 4, 123, 12, 666

      8
  44      55
4       12  66
             123
                666
```

Поиск по такому дереву происходит пойдёт сравнением искомого ключа со значением в узле и дальнейшим проходом налево, либо направо в зависимости от того, больше искомый ключ

```cpp

```