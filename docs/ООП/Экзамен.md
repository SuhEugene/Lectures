```
1. Основные идеи ООП: использование объекта в качестве основной компоненты программы и децентрализация управления, реализуемая представлением программы совокупностью взаимодействующих объектов  

    - В ООП программа строится вокруг объектов.  
    Объекты - это экземпляры классов.  
    Класс представляет собой структуру объекта.  
    Объекты взаимодействуют между собой, составляя структуру программы.
    
    - Каждый объект в программе самостоятельно управляет своим состоянием и поведением.  
    Они обмениваются между собой сообщениями и взаимодействуют.  
    Но каждый из них отвечает за свою часть функционала.
  
2. Сущность ООП: моделирование поведения объектов реального мира, наглядное представление объектов, создание и использование АТД, производные АТД
    - В ООП объекты программы представляют абстракции реальных объектов, обладающих свойствами и поведением.  
    Моделирование позволяет создавать структуры данных, отражающие реальные сущности, и определять их взаимодействие.
    
    - ООП обеспечивает удобное наглядное представление объектов и их взаимосвязей.  
    Это помогает разработчикам легче понимать и взаимодействовать с кодом, так как структуры данных и их взаимодействие отображают реальные объекты и их отношения.

3. Концепции ООП. Инкапсуляция и расширяемость типов

    - Инкапсуляция это упаковка данных и методов в единый компонент - класс.  

    Она позволяет скрыть внутренние детали реализации, предоставляя интерфейс взаимодействия с объектом.

    - Расширяемость типов - это полиморфизм.  

    Способность использовать объекты различных типов через общий интерфейс.  

  

4. Концепции ООП. Семантика объекта: данные как отражение состояния объекта и методы как средства обеспечения взаимодействия объектов. Представление данных. Классификация методов: конструкторы, деструкторы, селекторы, модификаторы.

    - Каждый из объектов содержит данные и методы.  

    Когда методы для всех объектов одного класса идентичны, данные различаются.  

    Данные отображают текущее состояние объекта.

    Методы же позволяют объектам взаимодействовать, они обеспечивают выполнение операций над данными объекта.

    - В каждом классе заранее известно какие методы и данные будут использованы.  

    Заранее известно, что у объекта будут определённые переменные, определяющие его состояние.  

    Также, как заранее известно, какие методы будет использовать сам объект, а какие могут использовать другие объекты для взаимодействия с этим.

  

5. Концепции ООП. Классы объектов: назначение и семантика, классы и абстрактные типы данных, наглядное представление классов. Объекты как экземпляры классов. Основные действия с объектами: создание, инициализация, обработка, разрушение.

    - Классы определяют шаблоны для создания объектов.  

    Они объединяют данные и методы  в единый тип.  

    Классы описывают как объекты данного класса должны вести себя и какими данными должны обладать.

    - Классы могут рассматриваться как реализации абстрактных типов данных (АТД).  

    Они предоставляют интерфейс для работы с данными, скрывая детали реализации.

    - ООП обеспечивает удобное наглядное представление объектов и их взаимосвязей.  

    Структуры данных и их взаимодействие отображают реальные объекты и их отношения.

    - При создании объекта выделяется память под него.  

    Инициализация - выполнение конструктора.  

    Обработка - работа с объектом, выполнение его методов.  

    Разрушение - выполнение деструктора и освобождение памяти.

  

6. Концепции ООП. Конструкторы и деструкторы, основное назначение

    - Конструктор – это метод класса, который вызывается при создании нового объекта этого класса.  

    Его основная задача – инициализировать начальное состояние объекта.

    - Деструкторы предназначены для выполнения операций при удалении объекта.  

    Они используются для освобождения ресурсов или проведения завершающих действий.

  

7. Концепции ООП. Перегрузка операторов и функций. Ключевые слова: friend, operator

    - Перегрузка функций позволяет определять функции с различными параметрами и возвращаемыми значениями, но одинаковым именем.

    - Операторы тоже могут быть перегружены.  

    Для этого используется синтаксис `operator` + сам оператор.  

    Это позволяет использовать нативно, более красиво различный функционал.

    - Дружественная функция может иметь доступ ко всем приватным и защищённым данным.  

    Объявляется друг через ключевое слово friend и объявление самого класса/функции.

  

8. Концепции ООП. Шаблоны и обобщенное программирование. Ключевое слово: template. Контейнерные классы

    - Шаблоны классов позволяют создавать классы и функции с заранее не определёнными константами и типами данных.

    - Контейнерные классы, такие как вектор, являются шаблонными классами, которые содержат множество экземпляров одного типа данных.

  

9. Концепции ООП. Основные составляющие STL: контейнеры, итераторы, алгоритмы

    - STL - Standard Template Library. Встроенная библиотека, включающая в себя контейнеры, итераторы и алгоритмы.

    - Из контейнеров содержит, вектор, список, очередь, стек, множество, map.

    - Итераторы: InputIterator - однонаправленный, BidirectionalIterator - двунаправленный, RandomAccessIterator - произвольного доступа.

    - Алгоритмы: сортировка, поиск, объединение, трансформация, удаление, агрегирование и генерация.

  

10. Концепции ООП. Наследование: базовый и производный класс, иерархия классов

    - Базовый класс - родительский класс. Производный класс - дочерний класс.  

    Дочерний класс определяется по родительскому.  

    Записывается `class ClassName2 : public ClassName1`.  

    Для обращения к родительским методам используется ключевое слово `base`.

  

11. Концепции ООП. Полиморфизм. Абстрактный базовый класс

    - Абстрактный базовый класс - это класс, который содержит хотя бы одну виртуальную функцию.  

    А так как есть виртуальная функция, значит объект класса создать невозможно.  

    Он служит в качестве интерфейса для производных классов, определяя общий набор методов, которые должны быть реализованы в этих производных классах.

  

12. Концепции ООП. Обработка исключительных ситуаций, проверка утверждений.

    - Ну там try catch, throw std::runtime_error("Чот произошло")

  

13. Концепции ООП. Преимущества и недостатки ООП. Основные свойства языка ООП. Место языка Си++ во внедрении и развитии средств ООП. Значение языка Си++ для профессиональной подготовки программистов

    - Преимущества:

      - Абстракции упрощают понимание

      - Инкапсуляция позволяет защищать данные

      - Наследование позволяет более удобно переиспользовать код

      - Разбиение программы уменьшает её сложность

    - Недостатки:

      - Меньшая скорость выполнения, стеку вызовов вообще весело там

      - Код переизбыточен, много букав

      - Концепции ООП сложны для новичков

    - НАСЛЕДОВАНИЕ, ИНКАПСУЛЯЦИЯ, ПОЛИМОРФИЗМ

    - С++ это мощное расширение C в сторону ООП, значительно упрощающее и оптимизирующее работу со сложными проектами  

    Он крут для создания ПО, он потому и стал популярным языком для разработки крупных проектов  

    Не зря на нём же сейчас из под Unreal Engine игры делаются

  
  

14. Классы: компонентные данные, компонентные функции, способы задания доступа, синтаксическая структура определения класса, объявление, определение и инициализация объектов, объекты объявленные как константы

    - Компонентные данные - переменные класса.

    - Компонентные функции - методы класса.

    - `public`: Данные и методы, объявленные в этом разделе, доступны извне класса.  

      `private`: Данные и методы, объявленные в этом разделе, доступны только внутри класса.  

      `protected`: Похож на `private`, но доступен и в производных классах.

    - Объявляется и определяется `ClassName a`

    - Инициализируется или вручную, или если есть конструктор, инициализирующий его.

    - Если ты объявил объект константой, то его данные не могут быть изменены после инициализации

  

15. Область видимости класса: оператор разрешения области видимости (::) - унарная форма, бинарная форма; вложенные классы - классы, вложенные в классы, классы, вложенные в блоки, вложенные определения функций

    - Область видимости расширяется для доступа к классам, вложенным в классы и их функциям.

    - Унарная - доступ к глобальным переменным

    - Бинарная - доступ к переменным и классам, внутри классов

    - Вложенные классы имеют доступ к приватным данным класса, в которые они вложены.

    - Классы и функции могут быть вложены в блоки и их областью видимости будет этот блок.

16. Компонентные данные: назначение, основные свойства, синтаксис и семантика определений компонентных данных, статические компонентные данные, статические константы, изменяемые компонентные данные (mutable)

  

17. Компонентные функции: назначение, основные свойства, доступ к компонентным функциям, доступ компонентных функций к компонентным данным - функции селекторы, функции модификаторы

18. Встроенные компонентные функции: назначение, синтаксис и семантика определения, рекомендации по использованию; компонентные функции, определяемые вне класса: назначение, синтаксис и семантика определения и объявления, рекомендации по использованию

19. Указатель this, компонентные функции типа static и const (статические и постоянные компонентные функции): назначение, синтаксис и семантика определения и объявления, рекомендации по использованию

20. Конструкторы: назначение, наличие нескольких конструкторов у одного класса - причины, разделение функций, способы задания конструктора: по умолчанию или явное

21. Явное описание (определение или объявление) конструктора, размещение определения в теле класса и влияние размещения на функции конструктора, размещение определения вне своего класса, параметры конструктора и возможности их использования

22. Конструкторы для инициализации объектов, инициализаторы конструктора; конструкторы для преобразования типов, ключевое слово explicit

23. Конструкторы умолчания: назначение, способы задания, правила описания

24. Конструкторы копирования: назначение, способы задания, правила описания

25. Вызов конструктора: назначение, способы реализации, задание аргументов; явный и автоматический вызовы: ситуации использования, рекомендации по применению

26. Деструкторы: назначение, основные свойства, способы задания: по умолчанию или явное

27. Явное описание (определение или объявление) деструктора, размещение определения в теле класса и влияние размещения на функции деструктора, размещение определения вне своего класса, параметры деструктора и возможности их использования

28. Вызов деструктора: назначение, способы реализации, явный и автоматический вызовы: ситуации использования, рекомендации по применению

29. Специальный полиморфизм – преобразование АТД к встроенному типу

30. Специальный полиморфизм – перегрузка функций, алгоритм выбора перегруженной функции

31. Дружественные функции: основные свойства, номенклатура, необходимость, полезность и опасность применения, наборы дружественных функций, дружественные классы

32. Дружественные функции: объявление – размещение, синтаксис, семантика, требования к параметрам и типу возвращаемого значения; определение – размещение, область видимости; вызов функции

33. Специальный полиморфизм – перегрузка операторов: синтаксис, семантика, приоритет и порядок выполнения, доступные и недоступные для перегрузки операторы, перегружаемые как обычные функции, только как компонентные функции

34. Перегрузка унарных и бинарных операторов: синтаксис и семантика

35. Перегрузка операторов присваивания и индексирования: синтаксис и семантика

    - Получает адрес, возвращает адрес

36. Перегрузка операторов ввода-вывода (<<, >>): синтаксис и семантика

    - Перегружаются как обычно, принимают на вход что угодно, делают с переменными что захотят.

37. Перегрузка оператора () для индексирования: синтаксис и семантика

    - Перегружается как обычно, принимает на вход что угодно, делает с переменным что захочет.

38. Перегрузка операторов доступа к элементу класса через указатель на объект ->: синтаксис и семантика

  Перегружается как обычно, возвращает адрес объекта и позволяет взаимодействие с его методами.

39. Перегрузка операторов new и delete: синтаксис и семантика

    - `new`

      - Открываем `void* operator new(size_t size)`

      - Пишем `void* ptr = ::operator new(size);`

      - Включаем кастомную логику

      - Завершаем `return ptr;`

    - `delete`

      - Открываем `void operator delete(void* ptr)`

      - Кастомная логика

      - Базовое удаление `::operator delete(ptr);`

      - Конец

  

40. Параметрический полиморфизм – шаблонные классы и шаблонные функции: назначение, параметризованные типы данных, синтаксис и семантика

    - Писал

  
  

41. Шаблоны классов: назначение, синтаксис и семантика, объявление и определение шаблона, дружественные шаблонному классу функции, статические элементы шаблонного класса, аргументы шаблона класса

    - Писал

    - Для того чтобы определить дружественную шаблонному классу функцию надо полностью скопипастить её с шаблоном

    - Статические переменные и методы живут вне пространства и времени, вне зависимости от дженерика

  

42. Шаблоны функций: назначение, синтаксис и семантика, объявление, определение, вызов и перегрузка шаблонных функций, аргументы шаблона функции

    - Писал
```